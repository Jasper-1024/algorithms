# 分治法

分治法: 分而治之,原问题解决不了,子问题还解决不了你吗?真解决不了分到能解决为止.

一般会是递归式的形式.

求解递归式的基本方法

- 代入法: 猜测一个上/下界,然后数学归纳法证明.
- 递归树法: 将递归式转换成一颗具体的递归树,计算树的高度和节点计算等推算界限.
- 主方法: 只能求解一种类型非常典型的递归式,非常方便.

## 求解递归式

### 代入法

代入法说穿了是猜测一个上/下界,然后数学归纳法证明.

猜上下界没有通用方法,全凭感觉/经验.不过证明倒是有一些套路(~~和坑~~)

一个例子:

- $T(n) = 4T(\frac{n}{4}) + n$
- $T(1) = \Theta(1)$
- 证明 $T(n)$ 时间复杂度

直观上,当子问题的规模缩小一半,会付出 4 倍的代价,可以猜测 $T(n)$ 的时间复杂度上限是 $O(n^2)$,这里给了 $O(n^3)$ 和 $O(n^2)$ 的证明.

证明的过程一般是严格的数学归纳法,只不过一般是假设结论对 $k(k \leq n)$ 成立,再归纳到 $T(1)$.

#### $n^3$

证明 $T(n) = O(n^3)$.

假设 $T(k) \leq ck^3 (k < n)$

则 
$$
\begin{align*}
T(n) & = 4T(\frac{n}{4}) + n \\
& \leq 4c(\frac{n}{2}) +n \\&= c\frac{n^3}{2} +n \\ 
&= cn^3 - (\frac{1}{2}cn^3 - n)
\end{align*}
$$

if $c \geq 1$ 则 $\frac{1}{2}cn^3 - n \geq 0$.

且 $T(1) = \Theta(1)$

所以 $T(n) = O(n^3)$

#### $n^2$

假如我们故技重施,直接代入 $T(k) \leq ck^2 (k < n)$ 结果会如何?

假设  $T(k) \leq ck^2 (k < n)$

则 

$$
\begin{align*}
T(n) & = 4T(\frac{n}{4}) + n \\
& \leq 4c(\frac{n}{2}) +n \\
&= cn^2 - (- n)
\end{align*}
$$

递归成立的条件是 $(-n) \leq 0$,显然这里是不成立的.此时就需要重新构建条件使得代入假设后的递归条件能成立才行.

上面的递归条件不成立的原因是 $(-n) \leq 0$ 不成立,处理 $-n$ 可以在假设上加入一个常数项.

假设 $T(k) \leq c_1k^2 - c_2k$

$$
\begin{align*}
T(n) & = 4T(\frac{n}{4}) + n \\
& \leq c_1n^2 -2c_2n + n\\
&= c_1n^2 - c_2n - (c_2 - 1)n
\end{align*}
$$

if $c_2 \geq 1$ 则 $(c_2 - 1)n \geq 0$.

至此假设对 $T(k)$ 成立.

$T(1)$ 代入假设, 有 $T(1) \leq c_1 - c_2$, 因为 $T(1) = \Theta(1)$ 所以还要有 $c_1 > c_2$.

因此当 $c_2 \geq 1$ 及  $c_1 > c_2$ 时,有$T(n) \leq c_1n^2 - c_2n$.

所以可以说 $T(n) = O(n^2)$

### 递归树

递归树是将递归树按照递归式展开一颗递归树,T(n) 就是递归树所有节点的代价之和.

以 $T(n) = T(\frac{n}{4}) + T(\frac{n}{2}) + n^2$ 为例.

### 主方法

主定理是求解一类递归式的通用方法.

$$
\begin{aligned}
& T(n) = aT(\frac{n}{b}) + f(n) \\
& a \geq 1,b > 1. \\
& f(n) 渐近趋正
\end{aligned}
$$

f(n) 渐近趋正: if n 足够大,则有 $f(n) > 0$

主定理分为 3 种情况(取决于 f(n) 的时间复杂度)

- if 存在 $\epsilon > 0$ 使得 $f(n) = O(n^{\log_{b}{a-\epsilon}})$ ,则 $T(n) =\Theta(n^{\log_{b}{a}})$
- $f(n) = \Theta(n^{\log_{b}{a}})$ 则 $T(n) =\Theta(n^{\log_{b}{a}} \lg{n})$
- if 存在 $\epsilon > 0$,使得 $f(n)=\Omega(n^{\log_{b}{a+\epsilon}})$,且对于某个常数 $c<1$ 和足够大的 n 有$af(\frac{n}{b}) \leq cf(n)$.则 $T(n) = \Theta(f(n))$,(原理是似乎是 $f(n)$ 的时间复杂度要小于上一层递归树的代价和)

主定理的证明

- 暂略(后补充)