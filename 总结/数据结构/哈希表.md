# 哈希表 & 哈希函数

使用哈希函数将键值映射到槽位.又称散列表,散列函数.

## 简单映射表

简单粗暴,将所有 key 的值域全部表示出来.有数据就放数据,没有数据就为空.

这样时间复杂度

- 插入: $O(1)$
- 删除: $O(1)$
- 查找: $O(1)$

面临几个问题

- key 值域很大,没法用.
- key 本身很复杂,例如 key 是32位数等
- key 是字符串,无法处理.

## 哈希表

简单映射表的问题来源于,直接将 key 寻址到存储,那可以在 key 到存储之间加上一层处理,避免直接寻址的问题.这个就是哈希表,处理 key 得到索引的函数就是哈希函数.

直观上哈希表能不能避免简单映射表的问题,取决于哈希函数.

即使使用哈希函数处理 key 也不大可能避免不同的 key 分配到相同的槽位,这种结果称为哈希碰撞,解决哈希碰撞有两种方法

- 拉链法: 一个槽位对应一个链表
- 开放寻址: 碰撞后再取新的槽位,直到找到空闲位置.

在分析具体哈希表时,我们需要一下前提

- 假设 key 是均匀分布的.
- n 个 key 对应到 m 个槽位
- $\frac{n}{m}$ 称为装载因子 $\alpha$.

### 拉链法

一个拉链法示例

![[哈希表-拉链法.jpeg]]

最坏时间复杂度: 所有 key 都发生了碰撞,对应哈希表退化到了单向链表.

- 插入/删除/查找: $\Theta(n)$

最好时间复杂度: 像简单映射表一样工作.

- 插入/删除/查找: $\Theta(1)$

平均时间复杂度,稍微复杂一些.

- 插入: 只需要进行哈希,时间复杂度 $\Theta(1)$

查找失败

- 每次肯定有哈希操作,$\Theta(1)$.


- 在 key 简单均匀分布情况下,每个槽位链表的平均长度为 $\frac{n}{m} = \alpha$.
- 查找失败即每次都走到了链表的末尾,因此时间复杂度是 $\Theta(1+\alpha)$

查找成功

- 每次肯定有哈希操作,$\Theta(1)$.
- 之后对于长度是 $\frac{n}{m} = \alpha$ 的单向链表,查找的时间复杂度为 $\Theta(\alpha)$
- 因此最终的时间复杂度为 $\Theta(1+\alpha)$.
- 严格的证明需要用到 [[指示器随机变量]],今天没带 🧠 暂时略过.

### 开放寻址

