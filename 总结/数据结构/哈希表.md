# 哈希表 & 哈希函数

使用哈希函数将键值映射到槽位.又称散列表,散列函数.

## 简单映射表

简单粗暴,将所有 key 的值域全部表示出来.有数据就放数据,没有数据就为空.

这样时间复杂度

- 插入: $O(1)$
- 删除: $O(1)$
- 查找: $O(1)$

面临几个问题

- key 值域很大,没法用.
- key 本身很复杂,例如 key 是32位数等
- key 是字符串,无法处理.

## 哈希表

简单映射表的问题来源于,直接将 key 寻址到存储,那可以在 key 到存储之间加上一层处理,避免直接寻址的问题.这个就是哈希表,处理 key 得到索引的函数就是哈希函数.

直观上哈希表能不能避免简单映射表的问题,取决于哈希函数.

即使使用哈希函数处理 key 也不大可能避免不同的 key 分配到相同的槽位,这种结果称为哈希碰撞,解决哈希碰撞有两种方法

- 拉链法: 一个槽位对应一个链表
- 开放寻址: 碰撞后再取新的槽位,直到找到空闲位置.

在分析具体哈希表时,我们需要一下前提

- 假设 key 是均匀分布的.
- n 个 key 对应到 m 个槽位
- $\frac{n}{m}$ 称为装载因子 $\alpha$.

### 拉链法

一个拉链法示例

![[哈希表-拉链法.jpeg]]

最坏时间复杂度: 所有 key 都发生了碰撞,对应哈希表退化到了单向链表.

- 插入/删除/查找: $\Theta(n)$

最好时间复杂度: 像简单映射表一样工作.

- 插入/删除/查找: $\Theta(1)$

平均时间复杂度,稍微复杂一些.

- 插入: 只需要进行哈希,时间复杂度 $\Theta(1)$

查找失败

- 每次肯定有哈希操作,$\Theta(1)$.


- 在 key 简单均匀分布情况下,每个槽位链表的平均长度为 $\frac{n}{m} = \alpha$.
- 查找失败即每次都走到了链表的末尾,因此时间复杂度是 $\Theta(1+\alpha)$

查找成功

- 每次肯定有哈希操作,$\Theta(1)$.
- 之后对于长度是 $\frac{n}{m} = \alpha$ 的单向链表,查找的时间复杂度为 $\Theta(\alpha)$
- 因此最终的时间复杂度为 $\Theta(1+\alpha)$.
- 严格的证明需要用到 [[指示器随机变量]],今天没带 🧠 暂时略过.

### 开放寻址

开放寻址对于哈希碰撞没有使用链表,而是直接再次算新的槽位.

哈希碰撞后,再次计算槽位的过程称为探查.不断探查新的槽位,构成一个探查序列.

特点

- 节省了指针的空间,同样空间有更多槽位.
- 不能直接删除元素,可能会破坏其他元素的探查序列.

哈希表的时间复杂度非常依赖存储时的均匀分布.对于开放寻址而言,这一点取决于探查的方式.

#### 探查方式

线性探查: 取 hash 值后,碰撞 +1,再碰撞再 +1.

$$
h(k,i) = (h'(k) + i) \bmod{m}
$$

- 非常容易实现
- 但是会有一次群集问题,一堆索引全部堆在一块.非常影响查找的时间复杂度.
- 一旦 $\alpha$ 稍大,一次群集问题会发展很快.

二次探查: 避免 +1 +1 的群集,改成通过参数计算.

$$
h(k,i) = (h'(k) + c_1i+c_2i^2) \bmod{m}
$$

- 二次探查尽力避免了一次群集问题
- 但是 $m c_1 c_2$ 的取值收到了限制,必须根据 key 等确定.
- 对于特定输入,依旧有二次群集问题(轻度).

双重散列: 既然二次探查根据参数算也不行,干脆再取一次 hash,根据第二个 hash 值算.

$$
h(k,i) = (h'(k) + ih''(k)) \bmod{m}
$$

- 理论上可能是最佳的.
- 为了能探查到整个表,$h''(k)$ 结果必须要有限制.理想情况下要和 m 互素.
- 取值,算法导论里提到了两种
	- m 取 $2^r$,而 $h''(k)$ 结果为奇数.
	- m 取素数, $h''(k)$ 总是结果总是比 m 小.

#### 时间复杂度

这里仅仅分析查找了,插入与删除都是以查找为基础.

查找失败

- 第一次探查发生碰撞概率: $\frac{n}{m} = \alpha$
- 第二次探查发生碰撞概率: $\frac{n-1}{m-1} < \alpha$
- 第三次探查发生碰撞概率: $\frac{n-2}{m-2} < \alpha$
- ...

