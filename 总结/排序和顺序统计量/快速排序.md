# 快速排序

快速排序基于分治法思想,最糟糕情况下其时间复杂度为 $O(n^2)$,平均情况下时间复杂度为 $O(n \lg n)$,且常数因子非常小.快排基本为原地排序(或很小的辅助栈),在一般情况下比其他排序算法要快的多.

快速排序的时间复杂度非常依赖输入的序列,算法给出了几个常用的改进型.

## 原始快速排序

依照 mit 算法导论公开课

步骤: 选取切分元素 x,递归切分直到子问题规模为 1,排序完成.

伪代码:

```r
partition(A,p,q) // 数组A[p,q]
    x <- A[p]
    l <- p
    for j<- p+1 to q
        do if A[j] <= x
        then  i <= i+1
              swap A[i] <--> A[j]
        swap A[p] <--> A[i]
    return i

Quicksort(A,p,q)
    if p < q
    then r <- partition(A,p,q)
         Quicksort(A,p,r-1)
         Quicksort(A,r+1,q)

Main call Quicksort(A,1,n)       
```

mit 公开课给出的快速排序和原始的快排/双指针版本等区别只在切分的实现,mit 版本伪代码更少,时间复杂度等都相同.

图解: ![quicksort](https://i.loli.net/2019/03/26/5c9a2d1650eb8.png)

### 算法正确性证明(分治法证明)

### 原始快排时间复杂度

我们假定输入的元素各不相同

最坏情况: 最坏情况下,输入序列正好是逆序,每次切分恰好只能将子问题的规模 -1.这种情况下快排将退化到指数时间复杂度.

- 设 $T(n)$ 时最坏情况下 quicksort 在输入规模为 n 上花费的时间代价.则有递归式 ($\Theta(n)$为切分操作的比较代价)
- $$T(n) = max_{0\leq q \leq n-1}(T(q)+T(n-q-1)) + \Theta(n)$$
  - 切分操作的两个子问题的规模为 n-1 ,所以参数 q 的取值范围为 $[0\leq q \leq n-1]$.

- 假设 $T(n) \leq cn^2$ ,c为常数.带回原递归方程得

- $$T(n) \leq max_{0\leq q \leq n-1}(cq^2 + c(n-q-1)^2) + \Theta(n) = c \times (q^2 + (n-q-1)^2) + \Theta(n)$$

- 方程 $q^2 + (n-q-1)^2$ ,在 $q = 0$ 或 $q=n-1$ 两个端点值时,取到最大值.因此二元一次方程得二阶导数为正,开口向上,其最大值为 $max_{0\leq q \leq n-1}(cq^2 + c(n-q-1)^2) \leq (n-1)^2 = n^2 -2n + 1$.带回原方程得.

- $$T(n) \leq cn^2 - c(2n-1) + \Theta(n) \leq cn^2$$

- 如上方程所示,常数c足够大,使 $c(2n-1) > \Theta(n)$,因此有 $T(n) = O(n^2)$

- 因此可以得到以下结论
  - 当两个子问题分别包含 n-1 和 0 个元素是快速排序的最坏情况.
  - 最坏情况下时间复杂度为 $O(n^2)$
  - 当切分元素选择首尾元素时,无论输入序列是逆序/有序,都是最坏情况,时间复杂度都是 $O(n^2)$.

最好情况

- 两个子问题规模都不到 $\frac n2$,(切分后一个为 $\frac n2$,另一个为 $\frac n2 - 1$),此时时间复杂度的递归式为
- $$T(n) = 2T(\frac n2) + \Theta(n)$$
- 由master定理得,时间复杂度为 $\Theta(n \lg n)$

固定切分

- 假设两个子问题的规模比值始终是 $9:1$.这里时间代价的递归式为
- $$T(n) = T(\frac{9n}{10}) +  T(\frac{n}{10}) + cn$$

- 这里将最好情况切分的 $\Theta(n)$ 显式写为了 $cn$.递归树分析比较合适.

- ![sort](https://i.loli.net/2019/03/26/5c9a2d2fccc48.png)

  - 树的高度 h, $\log_{10}n<h<\log_{\frac{10}{9}}n$
  - 从上到下,树的每一层的代价之和都是 $cn$,直到深度为 $\log_{10} n$ 为止,之后的每一层代价都小于 $cn$.因此有
  - $$cn*\log_{10}n + \Theta(n) < T(n) < \log_{\frac{10}{9}}n + \Theta(n)$$
    - $\Theta(n)$ 为叶子节点代价
  - 因此最好的时间复杂度为 $O(n \lg n)$

- 这里的结论可能有些反直觉,即: 在常数比例切分情况下,无论比例取值如何,时间复杂度都为 $O(n \lg n)$.只是其包含的常数项要比最好情况下更大.

平均时间复杂度

假设每次选取切分元素都是独立随机事件.随机变量指示器: 我们假设 $x_k$ 即选择了 $x_k$ 作为切分元素 $k \in [0,n-1]$

$$
x_k = \begin{cases}
& 1, 选择了 x_k \\
& 0, 其他情况
\end{cases}
$$

则 $x_k$ 的期望 $E[x_k]$ 就有

$$
\begin{equation}
\begin{aligned}
E[x_k] & = 0*Pr\{x_k = 0\} + 1*Pr\{x_k=1\} \\
&= Pr\{x_k=1\} \\
&= \frac{1}{n}
\end{aligned}
\end{equation}
$$

再回头看看 $T(n)$ 的表示

$$
T(n) = 
\begin{cases}
& \\
\end{cases}
$$










空间复杂度
- 对于使用原地排序的快速排序而言,不涉及辅助空间,空间消耗为递归栈.
- 最好情况下需要 $O(\lg n)$ 次调用,空间复杂度为 $O(\lg n)$
- 最坏情况下需要 $O(n)$ 次调用,空间复杂度为 $O(n)$