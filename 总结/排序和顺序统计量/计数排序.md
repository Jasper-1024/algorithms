# 计数排序

前文 [[基于比较排序下界|基于比较排序]] 证明了最坏情况下的下界只能是 $n\lgn$

要突破这个限制

- 需要从基于比较以外的角度思考排序.
- 或许需要对输入进行限制,以达到目的.

计数排序就是这么来的.

- 不再基于比较,而是通过元素在值域的分布排序
- 对输入数据进行了限制,必须是在一定范围内的整数.

计数排序基本思想是,不再比较,而是把元素的值直接放在表示整个值域的数组内计数.最后遍历值域得出元素的排序序号输出.

伪代码(来自 [[lec5.pdf#page=12]]):

```js
for i ← 1 to k
	do C[i] ← 0
for j ← 1 to n
	do C[A[j]] ← C[A[j]] + 1 ⊳ C[i] = |{key = i}|
for i ← 2 to k
	do C[i] ← C[i] + C[i–1] ⊳ C[i] = |{key ≤ i}|
for j ← n downto 1
	do B[C[A[j]]] ← A[j]
	C[A[j]] ← C[A[j]] – 1
```

说明
- 第一个 for 循环是初始化值域数组 C
- 第二个 for 循环是遍历 A,在值域数组 C 对应位置计数.
- 第三个 for 循环是从小到大遍历值域数组 C,不断累加,将第二个循环中对单个元素的计数值,转换成排序后 A 元素对应位置序号
- 第四个 for 循环是输出结果从后向前,`C[A[j]] ← C[A[j]] – 1` 是 A 内可能有重复元素,导致 C 计数大于 1.

## 例子

假设数组索引从 1 开始

输入 A = [6 5 7 4 5]

则值域数组 C[1:7],结果数组 B[4]

第一个循环,C 数组全部为 0.

第二个循环,C=[0,0,0,1,2,1,1]

第三个循环,C=[0,0,0,1,3,4,5]

第四个循环,

- B[3] = 5, C[5] = C[5] - 1 = 2
- B[1] = 4, C[4] = 0
- B[5] = 7, C[7] = 4
- B[2] = 5, C[5] = C[5] - 1 = 1
- B[4] = 6, C[6] = 3

最终 B = [4, 5, 5, 6, 7]

## 复杂度分析

首先是时间复杂度,上面说明中提到了 4 个循环

- 一 三是 $O(k)$
- 二四是 $O(n)$

所以最后shi