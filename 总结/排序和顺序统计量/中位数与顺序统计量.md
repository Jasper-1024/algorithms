# 中位数与顺序统计量

这一节似乎内容前后联系非常紧密,只能凑成长篇了.

顺序统计量:

- 一个元素互异的数组 A 的第 i 小的元素就是数组 A 的第 i 个顺序统计量.
- 最大值 i = n,最小值 i = 1.
- 中位数,需要考虑 n 奇偶,算法导论中是向下取整 $\lfloor \frac{n}{2} \rfloor$,下中位数 等同于 中位数.

最终这些问题汇聚成一个选择问题:

- 输入一个元素互异的数组 A 和整数 i ($[1,n]$)
- 输出 x ($\in{A}$),且 A 中恰好有 i -1 个元素小于 x.

## 最大最小值

单独找最大最小值,时间复杂度 $O(n)$.一个一个比较,留下那个较大/较小的.

同时找最大最小值,把上面的比较算法合并.这样比较的次数实际上是 2n-2.

还有种方法是两两比较,从较小值里再两两递归比较.这样还是 2n-2.

算法导论上提了一种:

- 记录当前最大最小值,之后输入两个值互相比较,再和当前最大最小值比较,这样 4 个数能节省 1 次比较,只需要比较 3 次.

## 期望时间为线性时间选择算法

这个算法的原理脱胎于快速排序,不断切分不断选择直到找到期望位置

伪代码 [[lec6.pdf#page=3]]

```
RAND-SELECT(A, p, q, i) // i 属于 [p..q] 
	if p= q  thenreturnA[p]
	r ← RAND-PARTITION(A, p, q)
	k ← r–p+1 // k = rank(A[r]) 随即快排的切分元素在 A 的位置
	if  i= k  then return A[r]
	if  i< k  
		then return RAND-SELECT(A, p, r –1, i)
		else return RAND-SELECT(A, r + 1, q, i –k)
```

空间复杂度一直是原地排序所以是 $O(1)$

### 最好/最坏情况

最好情况是每次都 $\frac12$ $\frac12$ 切分,这样

$$
T(n) = T(\frac12n) + \Theta(n)
$$

主定理,第三种情况.最后是 $\Theta(n)$.

其他情况下假设是 $\frac{1}{10}$ $\frac{9}{10}$ 切分,且不太幸运都在 $\frac{9}{10}$ 那一半.

$$
T(n) = T(\frac{9}{10}n) + \Theta(n)
$$

同理的主定理第三种情况,最后还是 $\Theta(n)$.

最坏情况,大概是切分每次只能使子问题规模 - 1.这样时间复杂度是等差数列求和,最后是 $O(n^2)$.

### 平均情况

与分析快速排序平均情况类似,这里要使用 [[指示器随机变量]].

定义指示器随机变量 $x_k$

$$

$$


